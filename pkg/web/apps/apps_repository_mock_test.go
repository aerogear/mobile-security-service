// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package apps

import (
	"github.com/aerogear/mobile-security-service/pkg/models"
	"sync"
)

var (
	lockRepositoryMockCreateApp                    sync.RWMutex
	lockRepositoryMockCreateNewDevice              sync.RWMutex
	lockRepositoryMockCreateNewVersion             sync.RWMutex
	lockRepositoryMockDeleteAppByAppID             sync.RWMutex
	lockRepositoryMockDisableAllAppVersionsByAppID sync.RWMutex
	lockRepositoryMockGetActiveAppByAppID          sync.RWMutex
	lockRepositoryMockGetActiveAppByID             sync.RWMutex
	lockRepositoryMockGetAppByAppID                sync.RWMutex
	lockRepositoryMockGetAppVersionsByAppID        sync.RWMutex
	lockRepositoryMockGetApps                      sync.RWMutex
	lockRepositoryMockGetDeviceByDeviceIDAndAppID  sync.RWMutex
	lockRepositoryMockGetDeviceByVersionAndAppID   sync.RWMutex
	lockRepositoryMockGetVersionByAppIDAndVersion  sync.RWMutex
	lockRepositoryMockIncrementVersionTotals       sync.RWMutex
	lockRepositoryMockUnDeleteAppByAppID           sync.RWMutex
	lockRepositoryMockUpdateAppVersions            sync.RWMutex
	lockRepositoryMockUpdateDeviceVersion          sync.RWMutex
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//     func TestSomethingThatUsesRepository(t *testing.T) {
//
//         // make and configure a mocked Repository
//         mockedRepository := &RepositoryMock{
//             CreateAppFunc: func(id string, appId string, name string) error {
// 	               panic("mock out the CreateApp method")
//             },
//             CreateNewDeviceFunc: func(device *models.Device) error {
// 	               panic("mock out the CreateNewDevice method")
//             },
//             CreateNewVersionFunc: func(version *models.Version) error {
// 	               panic("mock out the CreateNewVersion method")
//             },
//             DeleteAppByAppIDFunc: func(appId string) error {
// 	               panic("mock out the DeleteAppByAppID method")
//             },
//             DisableAllAppVersionsByAppIDFunc: func(appID string, message string) error {
// 	               panic("mock out the DisableAllAppVersionsByAppID method")
//             },
//             GetActiveAppByAppIDFunc: func(appID string) (*models.App, error) {
// 	               panic("mock out the GetActiveAppByAppID method")
//             },
//             GetActiveAppByIDFunc: func(ID string) (*models.App, error) {
// 	               panic("mock out the GetActiveAppByID method")
//             },
//             GetAppByAppIDFunc: func(appID string) (*models.App, error) {
// 	               panic("mock out the GetAppByAppID method")
//             },
//             GetAppVersionsByAppIDFunc: func(ID string) (*[]models.Version, error) {
// 	               panic("mock out the GetAppVersionsByAppID method")
//             },
//             GetAppsFunc: func() (*[]models.App, error) {
// 	               panic("mock out the GetApps method")
//             },
//             GetDeviceByDeviceIDAndAppIDFunc: func(deviceID string, appID string) (*models.Device, error) {
// 	               panic("mock out the GetDeviceByDeviceIDAndAppID method")
//             },
//             GetDeviceByVersionAndAppIDFunc: func(versionID string, appID string) (*models.Device, error) {
// 	               panic("mock out the GetDeviceByVersionAndAppID method")
//             },
//             GetVersionByAppIDAndVersionFunc: func(appID string, versionNumber string) (*models.Version, error) {
// 	               panic("mock out the GetVersionByAppIDAndVersion method")
//             },
//             IncrementVersionTotalsFunc: func(versionID string, isNewInstall bool) error {
// 	               panic("mock out the IncrementVersionTotals method")
//             },
//             UnDeleteAppByAppIDFunc: func(appID string) error {
// 	               panic("mock out the UnDeleteAppByAppID method")
//             },
//             UpdateAppVersionsFunc: func(versions []models.Version) error {
// 	               panic("mock out the UpdateAppVersions method")
//             },
//             UpdateDeviceVersionFunc: func(device *models.Device, version *models.Version) error {
// 	               panic("mock out the UpdateDeviceVersion method")
//             },
//         }
//
//         // use mockedRepository in code that requires Repository
//         // and then make assertions.
//
//     }
type RepositoryMock struct {
	// CreateAppFunc mocks the CreateApp method.
	CreateAppFunc func(id string, appId string, name string) error

	// CreateNewDeviceFunc mocks the CreateNewDevice method.
	CreateNewDeviceFunc func(device *models.Device) error

	// CreateNewVersionFunc mocks the CreateNewVersion method.
	CreateNewVersionFunc func(version *models.Version) error

	// DeleteAppByAppIDFunc mocks the DeleteAppByAppID method.
	DeleteAppByAppIDFunc func(appId string) error

	// DisableAllAppVersionsByAppIDFunc mocks the DisableAllAppVersionsByAppID method.
	DisableAllAppVersionsByAppIDFunc func(appID string, message string) error

	// GetActiveAppByAppIDFunc mocks the GetActiveAppByAppID method.
	GetActiveAppByAppIDFunc func(appID string) (*models.App, error)

	// GetActiveAppByIDFunc mocks the GetActiveAppByID method.
	GetActiveAppByIDFunc func(ID string) (*models.App, error)

	// GetAppByAppIDFunc mocks the GetAppByAppID method.
	GetAppByAppIDFunc func(appID string) (*models.App, error)

	// GetAppVersionsByAppIDFunc mocks the GetAppVersionsByAppID method.
	GetAppVersionsByAppIDFunc func(ID string) (*[]models.Version, error)

	// GetAppsFunc mocks the GetApps method.
	GetAppsFunc func() (*[]models.App, error)

	// GetDeviceByDeviceIDAndAppIDFunc mocks the GetDeviceByDeviceIDAndAppID method.
	GetDeviceByDeviceIDAndAppIDFunc func(deviceID string, appID string) (*models.Device, error)

	// GetDeviceByVersionAndAppIDFunc mocks the GetDeviceByVersionAndAppID method.
	GetDeviceByVersionAndAppIDFunc func(versionID string, appID string) (*models.Device, error)

	// GetVersionByAppIDAndVersionFunc mocks the GetVersionByAppIDAndVersion method.
	GetVersionByAppIDAndVersionFunc func(appID string, versionNumber string) (*models.Version, error)

	// IncrementVersionTotalsFunc mocks the IncrementVersionTotals method.
	IncrementVersionTotalsFunc func(versionID string, isNewInstall bool) error

	// UnDeleteAppByAppIDFunc mocks the UnDeleteAppByAppID method.
	UnDeleteAppByAppIDFunc func(appID string) error

	// UpdateAppVersionsFunc mocks the UpdateAppVersions method.
	UpdateAppVersionsFunc func(versions []models.Version) error

	// UpdateDeviceVersionFunc mocks the UpdateDeviceVersion method.
	UpdateDeviceVersionFunc func(device *models.Device, version *models.Version) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateApp holds details about calls to the CreateApp method.
		CreateApp []struct {
			// ID is the id argument value.
			ID string
			// AppId is the appId argument value.
			AppId string
			// Name is the name argument value.
			Name string
		}
		// CreateNewDevice holds details about calls to the CreateNewDevice method.
		CreateNewDevice []struct {
			// Device is the device argument value.
			Device *models.Device
		}
		// CreateNewVersion holds details about calls to the CreateNewVersion method.
		CreateNewVersion []struct {
			// Version is the version argument value.
			Version *models.Version
		}
		// DeleteAppByAppID holds details about calls to the DeleteAppByAppID method.
		DeleteAppByAppID []struct {
			// AppId is the appId argument value.
			AppId string
		}
		// DisableAllAppVersionsByAppID holds details about calls to the DisableAllAppVersionsByAppID method.
		DisableAllAppVersionsByAppID []struct {
			// AppID is the appID argument value.
			AppID string
			// Message is the message argument value.
			Message string
		}
		// GetActiveAppByAppID holds details about calls to the GetActiveAppByAppID method.
		GetActiveAppByAppID []struct {
			// AppID is the appID argument value.
			AppID string
		}
		// GetActiveAppByID holds details about calls to the GetActiveAppByID method.
		GetActiveAppByID []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetAppByAppID holds details about calls to the GetAppByAppID method.
		GetAppByAppID []struct {
			// AppID is the appID argument value.
			AppID string
		}
		// GetAppVersionsByAppID holds details about calls to the GetAppVersionsByAppID method.
		GetAppVersionsByAppID []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetApps holds details about calls to the GetApps method.
		GetApps []struct {
		}
		// GetDeviceByDeviceIDAndAppID holds details about calls to the GetDeviceByDeviceIDAndAppID method.
		GetDeviceByDeviceIDAndAppID []struct {
			// DeviceID is the deviceID argument value.
			DeviceID string
			// AppID is the appID argument value.
			AppID string
		}
		// GetDeviceByVersionAndAppID holds details about calls to the GetDeviceByVersionAndAppID method.
		GetDeviceByVersionAndAppID []struct {
			// VersionID is the versionID argument value.
			VersionID string
			// AppID is the appID argument value.
			AppID string
		}
		// GetVersionByAppIDAndVersion holds details about calls to the GetVersionByAppIDAndVersion method.
		GetVersionByAppIDAndVersion []struct {
			// AppID is the appID argument value.
			AppID string
			// VersionNumber is the versionNumber argument value.
			VersionNumber string
		}
		// IncrementVersionTotals holds details about calls to the IncrementVersionTotals method.
		IncrementVersionTotals []struct {
			// VersionID is the versionID argument value.
			VersionID string
			// IsNewInstall is the isNewInstall argument value.
			IsNewInstall bool
		}
		// UnDeleteAppByAppID holds details about calls to the UnDeleteAppByAppID method.
		UnDeleteAppByAppID []struct {
			// AppID is the appID argument value.
			AppID string
		}
		// UpdateAppVersions holds details about calls to the UpdateAppVersions method.
		UpdateAppVersions []struct {
			// Versions is the versions argument value.
			Versions []models.Version
		}
		// UpdateDeviceVersion holds details about calls to the UpdateDeviceVersion method.
		UpdateDeviceVersion []struct {
			// Device is the device argument value.
			Device *models.Device
			// Version is the version argument value.
			Version *models.Version
		}
	}
}

// CreateApp calls CreateAppFunc.
func (mock *RepositoryMock) CreateApp(id string, appId string, name string) error {
	if mock.CreateAppFunc == nil {
		panic("RepositoryMock.CreateAppFunc: method is nil but Repository.CreateApp was just called")
	}
	callInfo := struct {
		ID    string
		AppId string
		Name  string
	}{
		ID:    id,
		AppId: appId,
		Name:  name,
	}
	lockRepositoryMockCreateApp.Lock()
	mock.calls.CreateApp = append(mock.calls.CreateApp, callInfo)
	lockRepositoryMockCreateApp.Unlock()
	return mock.CreateAppFunc(id, appId, name)
}

// CreateAppCalls gets all the calls that were made to CreateApp.
// Check the length with:
//     len(mockedRepository.CreateAppCalls())
func (mock *RepositoryMock) CreateAppCalls() []struct {
	ID    string
	AppId string
	Name  string
} {
	var calls []struct {
		ID    string
		AppId string
		Name  string
	}
	lockRepositoryMockCreateApp.RLock()
	calls = mock.calls.CreateApp
	lockRepositoryMockCreateApp.RUnlock()
	return calls
}

// CreateNewDevice calls CreateNewDeviceFunc.
func (mock *RepositoryMock) CreateNewDevice(device *models.Device) error {
	if mock.CreateNewDeviceFunc == nil {
		panic("RepositoryMock.CreateNewDeviceFunc: method is nil but Repository.CreateNewDevice was just called")
	}
	callInfo := struct {
		Device *models.Device
	}{
		Device: device,
	}
	lockRepositoryMockCreateNewDevice.Lock()
	mock.calls.CreateNewDevice = append(mock.calls.CreateNewDevice, callInfo)
	lockRepositoryMockCreateNewDevice.Unlock()
	return mock.CreateNewDeviceFunc(device)
}

// CreateNewDeviceCalls gets all the calls that were made to CreateNewDevice.
// Check the length with:
//     len(mockedRepository.CreateNewDeviceCalls())
func (mock *RepositoryMock) CreateNewDeviceCalls() []struct {
	Device *models.Device
} {
	var calls []struct {
		Device *models.Device
	}
	lockRepositoryMockCreateNewDevice.RLock()
	calls = mock.calls.CreateNewDevice
	lockRepositoryMockCreateNewDevice.RUnlock()
	return calls
}

// CreateNewVersion calls CreateNewVersionFunc.
func (mock *RepositoryMock) CreateNewVersion(version *models.Version) error {
	if mock.CreateNewVersionFunc == nil {
		panic("RepositoryMock.CreateNewVersionFunc: method is nil but Repository.CreateNewVersion was just called")
	}
	callInfo := struct {
		Version *models.Version
	}{
		Version: version,
	}
	lockRepositoryMockCreateNewVersion.Lock()
	mock.calls.CreateNewVersion = append(mock.calls.CreateNewVersion, callInfo)
	lockRepositoryMockCreateNewVersion.Unlock()
	return mock.CreateNewVersionFunc(version)
}

// CreateNewVersionCalls gets all the calls that were made to CreateNewVersion.
// Check the length with:
//     len(mockedRepository.CreateNewVersionCalls())
func (mock *RepositoryMock) CreateNewVersionCalls() []struct {
	Version *models.Version
} {
	var calls []struct {
		Version *models.Version
	}
	lockRepositoryMockCreateNewVersion.RLock()
	calls = mock.calls.CreateNewVersion
	lockRepositoryMockCreateNewVersion.RUnlock()
	return calls
}

// DeleteAppByAppID calls DeleteAppByAppIDFunc.
func (mock *RepositoryMock) DeleteAppByAppID(appId string) error {
	if mock.DeleteAppByAppIDFunc == nil {
		panic("RepositoryMock.DeleteAppByAppIDFunc: method is nil but Repository.DeleteAppByAppID was just called")
	}
	callInfo := struct {
		AppId string
	}{
		AppId: appId,
	}
	lockRepositoryMockDeleteAppByAppID.Lock()
	mock.calls.DeleteAppByAppID = append(mock.calls.DeleteAppByAppID, callInfo)
	lockRepositoryMockDeleteAppByAppID.Unlock()
	return mock.DeleteAppByAppIDFunc(appId)
}

// DeleteAppByAppIDCalls gets all the calls that were made to DeleteAppByAppID.
// Check the length with:
//     len(mockedRepository.DeleteAppByAppIDCalls())
func (mock *RepositoryMock) DeleteAppByAppIDCalls() []struct {
	AppId string
} {
	var calls []struct {
		AppId string
	}
	lockRepositoryMockDeleteAppByAppID.RLock()
	calls = mock.calls.DeleteAppByAppID
	lockRepositoryMockDeleteAppByAppID.RUnlock()
	return calls
}

// DisableAllAppVersionsByAppID calls DisableAllAppVersionsByAppIDFunc.
func (mock *RepositoryMock) DisableAllAppVersionsByAppID(appID string, message string) error {
	if mock.DisableAllAppVersionsByAppIDFunc == nil {
		panic("RepositoryMock.DisableAllAppVersionsByAppIDFunc: method is nil but Repository.DisableAllAppVersionsByAppID was just called")
	}
	callInfo := struct {
		AppID   string
		Message string
	}{
		AppID:   appID,
		Message: message,
	}
	lockRepositoryMockDisableAllAppVersionsByAppID.Lock()
	mock.calls.DisableAllAppVersionsByAppID = append(mock.calls.DisableAllAppVersionsByAppID, callInfo)
	lockRepositoryMockDisableAllAppVersionsByAppID.Unlock()
	return mock.DisableAllAppVersionsByAppIDFunc(appID, message)
}

// DisableAllAppVersionsByAppIDCalls gets all the calls that were made to DisableAllAppVersionsByAppID.
// Check the length with:
//     len(mockedRepository.DisableAllAppVersionsByAppIDCalls())
func (mock *RepositoryMock) DisableAllAppVersionsByAppIDCalls() []struct {
	AppID   string
	Message string
} {
	var calls []struct {
		AppID   string
		Message string
	}
	lockRepositoryMockDisableAllAppVersionsByAppID.RLock()
	calls = mock.calls.DisableAllAppVersionsByAppID
	lockRepositoryMockDisableAllAppVersionsByAppID.RUnlock()
	return calls
}

// GetActiveAppByAppID calls GetActiveAppByAppIDFunc.
func (mock *RepositoryMock) GetActiveAppByAppID(appID string) (*models.App, error) {
	if mock.GetActiveAppByAppIDFunc == nil {
		panic("RepositoryMock.GetActiveAppByAppIDFunc: method is nil but Repository.GetActiveAppByAppID was just called")
	}
	callInfo := struct {
		AppID string
	}{
		AppID: appID,
	}
	lockRepositoryMockGetActiveAppByAppID.Lock()
	mock.calls.GetActiveAppByAppID = append(mock.calls.GetActiveAppByAppID, callInfo)
	lockRepositoryMockGetActiveAppByAppID.Unlock()
	return mock.GetActiveAppByAppIDFunc(appID)
}

// GetActiveAppByAppIDCalls gets all the calls that were made to GetActiveAppByAppID.
// Check the length with:
//     len(mockedRepository.GetActiveAppByAppIDCalls())
func (mock *RepositoryMock) GetActiveAppByAppIDCalls() []struct {
	AppID string
} {
	var calls []struct {
		AppID string
	}
	lockRepositoryMockGetActiveAppByAppID.RLock()
	calls = mock.calls.GetActiveAppByAppID
	lockRepositoryMockGetActiveAppByAppID.RUnlock()
	return calls
}

// GetActiveAppByID calls GetActiveAppByIDFunc.
func (mock *RepositoryMock) GetActiveAppByID(ID string) (*models.App, error) {
	if mock.GetActiveAppByIDFunc == nil {
		panic("RepositoryMock.GetActiveAppByIDFunc: method is nil but Repository.GetActiveAppByID was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockRepositoryMockGetActiveAppByID.Lock()
	mock.calls.GetActiveAppByID = append(mock.calls.GetActiveAppByID, callInfo)
	lockRepositoryMockGetActiveAppByID.Unlock()
	return mock.GetActiveAppByIDFunc(ID)
}

// GetActiveAppByIDCalls gets all the calls that were made to GetActiveAppByID.
// Check the length with:
//     len(mockedRepository.GetActiveAppByIDCalls())
func (mock *RepositoryMock) GetActiveAppByIDCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockRepositoryMockGetActiveAppByID.RLock()
	calls = mock.calls.GetActiveAppByID
	lockRepositoryMockGetActiveAppByID.RUnlock()
	return calls
}

// GetAppByAppID calls GetAppByAppIDFunc.
func (mock *RepositoryMock) GetAppByAppID(appID string) (*models.App, error) {
	if mock.GetAppByAppIDFunc == nil {
		panic("RepositoryMock.GetAppByAppIDFunc: method is nil but Repository.GetAppByAppID was just called")
	}
	callInfo := struct {
		AppID string
	}{
		AppID: appID,
	}
	lockRepositoryMockGetAppByAppID.Lock()
	mock.calls.GetAppByAppID = append(mock.calls.GetAppByAppID, callInfo)
	lockRepositoryMockGetAppByAppID.Unlock()
	return mock.GetAppByAppIDFunc(appID)
}

// GetAppByAppIDCalls gets all the calls that were made to GetAppByAppID.
// Check the length with:
//     len(mockedRepository.GetAppByAppIDCalls())
func (mock *RepositoryMock) GetAppByAppIDCalls() []struct {
	AppID string
} {
	var calls []struct {
		AppID string
	}
	lockRepositoryMockGetAppByAppID.RLock()
	calls = mock.calls.GetAppByAppID
	lockRepositoryMockGetAppByAppID.RUnlock()
	return calls
}

// GetAppVersionsByAppID calls GetAppVersionsByAppIDFunc.
func (mock *RepositoryMock) GetAppVersionsByAppID(ID string) (*[]models.Version, error) {
	if mock.GetAppVersionsByAppIDFunc == nil {
		panic("RepositoryMock.GetAppVersionsByAppIDFunc: method is nil but Repository.GetAppVersionsByAppID was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockRepositoryMockGetAppVersionsByAppID.Lock()
	mock.calls.GetAppVersionsByAppID = append(mock.calls.GetAppVersionsByAppID, callInfo)
	lockRepositoryMockGetAppVersionsByAppID.Unlock()
	return mock.GetAppVersionsByAppIDFunc(ID)
}

// GetAppVersionsByAppIDCalls gets all the calls that were made to GetAppVersionsByAppID.
// Check the length with:
//     len(mockedRepository.GetAppVersionsByAppIDCalls())
func (mock *RepositoryMock) GetAppVersionsByAppIDCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockRepositoryMockGetAppVersionsByAppID.RLock()
	calls = mock.calls.GetAppVersionsByAppID
	lockRepositoryMockGetAppVersionsByAppID.RUnlock()
	return calls
}

// GetApps calls GetAppsFunc.
func (mock *RepositoryMock) GetApps() (*[]models.App, error) {
	if mock.GetAppsFunc == nil {
		panic("RepositoryMock.GetAppsFunc: method is nil but Repository.GetApps was just called")
	}
	callInfo := struct {
	}{}
	lockRepositoryMockGetApps.Lock()
	mock.calls.GetApps = append(mock.calls.GetApps, callInfo)
	lockRepositoryMockGetApps.Unlock()
	return mock.GetAppsFunc()
}

// GetAppsCalls gets all the calls that were made to GetApps.
// Check the length with:
//     len(mockedRepository.GetAppsCalls())
func (mock *RepositoryMock) GetAppsCalls() []struct {
} {
	var calls []struct {
	}
	lockRepositoryMockGetApps.RLock()
	calls = mock.calls.GetApps
	lockRepositoryMockGetApps.RUnlock()
	return calls
}

// GetDeviceByDeviceIDAndAppID calls GetDeviceByDeviceIDAndAppIDFunc.
func (mock *RepositoryMock) GetDeviceByDeviceIDAndAppID(deviceID string, appID string) (*models.Device, error) {
	if mock.GetDeviceByDeviceIDAndAppIDFunc == nil {
		panic("RepositoryMock.GetDeviceByDeviceIDAndAppIDFunc: method is nil but Repository.GetDeviceByDeviceIDAndAppID was just called")
	}
	callInfo := struct {
		DeviceID string
		AppID    string
	}{
		DeviceID: deviceID,
		AppID:    appID,
	}
	lockRepositoryMockGetDeviceByDeviceIDAndAppID.Lock()
	mock.calls.GetDeviceByDeviceIDAndAppID = append(mock.calls.GetDeviceByDeviceIDAndAppID, callInfo)
	lockRepositoryMockGetDeviceByDeviceIDAndAppID.Unlock()
	return mock.GetDeviceByDeviceIDAndAppIDFunc(deviceID, appID)
}

// GetDeviceByDeviceIDAndAppIDCalls gets all the calls that were made to GetDeviceByDeviceIDAndAppID.
// Check the length with:
//     len(mockedRepository.GetDeviceByDeviceIDAndAppIDCalls())
func (mock *RepositoryMock) GetDeviceByDeviceIDAndAppIDCalls() []struct {
	DeviceID string
	AppID    string
} {
	var calls []struct {
		DeviceID string
		AppID    string
	}
	lockRepositoryMockGetDeviceByDeviceIDAndAppID.RLock()
	calls = mock.calls.GetDeviceByDeviceIDAndAppID
	lockRepositoryMockGetDeviceByDeviceIDAndAppID.RUnlock()
	return calls
}

// GetDeviceByVersionAndAppID calls GetDeviceByVersionAndAppIDFunc.
func (mock *RepositoryMock) GetDeviceByVersionAndAppID(versionID string, appID string) (*models.Device, error) {
	if mock.GetDeviceByVersionAndAppIDFunc == nil {
		panic("RepositoryMock.GetDeviceByVersionAndAppIDFunc: method is nil but Repository.GetDeviceByVersionAndAppID was just called")
	}
	callInfo := struct {
		VersionID string
		AppID     string
	}{
		VersionID: versionID,
		AppID:     appID,
	}
	lockRepositoryMockGetDeviceByVersionAndAppID.Lock()
	mock.calls.GetDeviceByVersionAndAppID = append(mock.calls.GetDeviceByVersionAndAppID, callInfo)
	lockRepositoryMockGetDeviceByVersionAndAppID.Unlock()
	return mock.GetDeviceByVersionAndAppIDFunc(versionID, appID)
}

// GetDeviceByVersionAndAppIDCalls gets all the calls that were made to GetDeviceByVersionAndAppID.
// Check the length with:
//     len(mockedRepository.GetDeviceByVersionAndAppIDCalls())
func (mock *RepositoryMock) GetDeviceByVersionAndAppIDCalls() []struct {
	VersionID string
	AppID     string
} {
	var calls []struct {
		VersionID string
		AppID     string
	}
	lockRepositoryMockGetDeviceByVersionAndAppID.RLock()
	calls = mock.calls.GetDeviceByVersionAndAppID
	lockRepositoryMockGetDeviceByVersionAndAppID.RUnlock()
	return calls
}

// GetVersionByAppIDAndVersion calls GetVersionByAppIDAndVersionFunc.
func (mock *RepositoryMock) GetVersionByAppIDAndVersion(appID string, versionNumber string) (*models.Version, error) {
	if mock.GetVersionByAppIDAndVersionFunc == nil {
		panic("RepositoryMock.GetVersionByAppIDAndVersionFunc: method is nil but Repository.GetVersionByAppIDAndVersion was just called")
	}
	callInfo := struct {
		AppID         string
		VersionNumber string
	}{
		AppID:         appID,
		VersionNumber: versionNumber,
	}
	lockRepositoryMockGetVersionByAppIDAndVersion.Lock()
	mock.calls.GetVersionByAppIDAndVersion = append(mock.calls.GetVersionByAppIDAndVersion, callInfo)
	lockRepositoryMockGetVersionByAppIDAndVersion.Unlock()
	return mock.GetVersionByAppIDAndVersionFunc(appID, versionNumber)
}

// GetVersionByAppIDAndVersionCalls gets all the calls that were made to GetVersionByAppIDAndVersion.
// Check the length with:
//     len(mockedRepository.GetVersionByAppIDAndVersionCalls())
func (mock *RepositoryMock) GetVersionByAppIDAndVersionCalls() []struct {
	AppID         string
	VersionNumber string
} {
	var calls []struct {
		AppID         string
		VersionNumber string
	}
	lockRepositoryMockGetVersionByAppIDAndVersion.RLock()
	calls = mock.calls.GetVersionByAppIDAndVersion
	lockRepositoryMockGetVersionByAppIDAndVersion.RUnlock()
	return calls
}

// IncrementVersionTotals calls IncrementVersionTotalsFunc.
func (mock *RepositoryMock) IncrementVersionTotals(versionID string, isNewInstall bool) error {
	if mock.IncrementVersionTotalsFunc == nil {
		panic("RepositoryMock.IncrementVersionTotalsFunc: method is nil but Repository.IncrementVersionTotals was just called")
	}
	callInfo := struct {
		VersionID    string
		IsNewInstall bool
	}{
		VersionID:    versionID,
		IsNewInstall: isNewInstall,
	}
	lockRepositoryMockIncrementVersionTotals.Lock()
	mock.calls.IncrementVersionTotals = append(mock.calls.IncrementVersionTotals, callInfo)
	lockRepositoryMockIncrementVersionTotals.Unlock()
	return mock.IncrementVersionTotalsFunc(versionID, isNewInstall)
}

// IncrementVersionTotalsCalls gets all the calls that were made to IncrementVersionTotals.
// Check the length with:
//     len(mockedRepository.IncrementVersionTotalsCalls())
func (mock *RepositoryMock) IncrementVersionTotalsCalls() []struct {
	VersionID    string
	IsNewInstall bool
} {
	var calls []struct {
		VersionID    string
		IsNewInstall bool
	}
	lockRepositoryMockIncrementVersionTotals.RLock()
	calls = mock.calls.IncrementVersionTotals
	lockRepositoryMockIncrementVersionTotals.RUnlock()
	return calls
}

// UnDeleteAppByAppID calls UnDeleteAppByAppIDFunc.
func (mock *RepositoryMock) UnDeleteAppByAppID(appID string) error {
	if mock.UnDeleteAppByAppIDFunc == nil {
		panic("RepositoryMock.UnDeleteAppByAppIDFunc: method is nil but Repository.UnDeleteAppByAppID was just called")
	}
	callInfo := struct {
		AppID string
	}{
		AppID: appID,
	}
	lockRepositoryMockUnDeleteAppByAppID.Lock()
	mock.calls.UnDeleteAppByAppID = append(mock.calls.UnDeleteAppByAppID, callInfo)
	lockRepositoryMockUnDeleteAppByAppID.Unlock()
	return mock.UnDeleteAppByAppIDFunc(appID)
}

// UnDeleteAppByAppIDCalls gets all the calls that were made to UnDeleteAppByAppID.
// Check the length with:
//     len(mockedRepository.UnDeleteAppByAppIDCalls())
func (mock *RepositoryMock) UnDeleteAppByAppIDCalls() []struct {
	AppID string
} {
	var calls []struct {
		AppID string
	}
	lockRepositoryMockUnDeleteAppByAppID.RLock()
	calls = mock.calls.UnDeleteAppByAppID
	lockRepositoryMockUnDeleteAppByAppID.RUnlock()
	return calls
}

// UpdateAppVersions calls UpdateAppVersionsFunc.
func (mock *RepositoryMock) UpdateAppVersions(versions []models.Version) error {
	if mock.UpdateAppVersionsFunc == nil {
		panic("RepositoryMock.UpdateAppVersionsFunc: method is nil but Repository.UpdateAppVersions was just called")
	}
	callInfo := struct {
		Versions []models.Version
	}{
		Versions: versions,
	}
	lockRepositoryMockUpdateAppVersions.Lock()
	mock.calls.UpdateAppVersions = append(mock.calls.UpdateAppVersions, callInfo)
	lockRepositoryMockUpdateAppVersions.Unlock()
	return mock.UpdateAppVersionsFunc(versions)
}

// UpdateAppVersionsCalls gets all the calls that were made to UpdateAppVersions.
// Check the length with:
//     len(mockedRepository.UpdateAppVersionsCalls())
func (mock *RepositoryMock) UpdateAppVersionsCalls() []struct {
	Versions []models.Version
} {
	var calls []struct {
		Versions []models.Version
	}
	lockRepositoryMockUpdateAppVersions.RLock()
	calls = mock.calls.UpdateAppVersions
	lockRepositoryMockUpdateAppVersions.RUnlock()
	return calls
}

// UpdateDeviceVersion calls UpdateDeviceVersionFunc.
func (mock *RepositoryMock) UpdateDeviceVersion(device *models.Device, version *models.Version) error {
	if mock.UpdateDeviceVersionFunc == nil {
		panic("RepositoryMock.UpdateDeviceVersionFunc: method is nil but Repository.UpdateDeviceVersion was just called")
	}
	callInfo := struct {
		Device  *models.Device
		Version *models.Version
	}{
		Device:  device,
		Version: version,
	}
	lockRepositoryMockUpdateDeviceVersion.Lock()
	mock.calls.UpdateDeviceVersion = append(mock.calls.UpdateDeviceVersion, callInfo)
	lockRepositoryMockUpdateDeviceVersion.Unlock()
	return mock.UpdateDeviceVersionFunc(device, version)
}

// UpdateDeviceVersionCalls gets all the calls that were made to UpdateDeviceVersion.
// Check the length with:
//     len(mockedRepository.UpdateDeviceVersionCalls())
func (mock *RepositoryMock) UpdateDeviceVersionCalls() []struct {
	Device  *models.Device
	Version *models.Version
} {
	var calls []struct {
		Device  *models.Device
		Version *models.Version
	}
	lockRepositoryMockUpdateDeviceVersion.RLock()
	calls = mock.calls.UpdateDeviceVersion
	lockRepositoryMockUpdateDeviceVersion.RUnlock()
	return calls
}
